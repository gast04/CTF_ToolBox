import angr, claripy, IPython, logging
import signal, sys, os

def fuckmyself():
    os.system('kill %d' % os.getpid())
def sigint_handler(signum, frame):
    IPython.embed()

signal.signal(signal.SIGINT, sigint_handler)

logfile = open("angr_log","w+")

#logging.getLogger('angr.sim_manager').setLevel('INFO')
logging.getLogger('angr.sim_manager').setLevel('DEBUG')

# loading options
load_offset = 0x400000
load_options = {}
load_options['auto_load_libs'] = False
load_options['main_opts'] = {'base_addr': load_offset} 

# input 
argv1 = claripy.BVS("argv1", 20 * 8)
angrproj = angr.Project("Bob.exe", load_options=load_options)

start_state = angrproj.factory.entry_state(args=["Bob.exe", argv1], remove_options={angr.options.LAZY_SOLVES})
#start_state = angrproj.factory.entry_state()

# assumption that argv1 is printable
for byte in argv1.chop(8):
	start_state.add_constraints(byte >= 0x20)  
	start_state.add_constraints(byte <= 0x7E)	

# write argv to memory and start from wanted function
start_state.memory.store(0x0020000, argv1)
start_state.memory.store(0x0020021, 0) # to terminate strlen

start_state.regs.eip = load_offset + 0x5950 # function
start_state.regs.ecx = 0x0020000 # input
 
pg = angrproj.factory.simulation_manager(start_state)

'''
# for single debugging
while(True):
  pg.run(n=1)
  i = 0
  for active in pg.active:
    print("{} : {}".format(hex(active.solver.eval(active.ip)), i))
    i += 1

  if i == 10:
    IPython.embed()
'''

# assumption that input is 20
pg.explore(find=0x40598D)

print("\n\nModify FOUND STATE")
f_state = pg.found[0]
f_state.regs.edx = 20 # set length constant

# continue with the modified state
pg = angrproj.factory.simulation_manager(f_state)

# try deep first search
pg.use_technique(angr.exploration_techniques.DFS())


def debug_print():
  print("\n")
  print("ENTER INNER FUNCTION")
  logfile.write("ENTER INNER FUNCTION\n")
  logfile.flush()
  print("\n")

angrproj.hook(0x403250, debug_print())


print("Continue Execution\n\n")
pg.explore(find=0x405AE8, 
  avoid=[0x405BCE,  # main function return
         0x405BC0,  # main functuin exit
         0x4021A5,  # xlength error
         0x4041EB,  # invalid parameter
         0x402FF6,  # invalid length
         0x406D26,
         0x40692F,
         0x405ED0,
         0x4016A3,
         0x4012A0,
         0x40147B,
         0x401D31,
         0x403017,
         0x405992,   # avoid length under 20
         0x404136,
         0x4032DA,
         0x404A3D
        ])
 
print(pg)
state_found = pg.found[0]
 
# desired output hash
s_hash = [0x1b ,0xe6 ,0x0a ,0x3a ,0x1f ,0x85 ,0x0d ,0x92 ,0x35 ,
		0x10 ,0xd8 ,0xa4 ,0xcd ,0x56 ,0x63 ,0x1b ,0xd0 ,0xd8 ,
		0x64 ,0x34]

# outputhash at ebp + 0x44

hashout = state_found.memory.load(state_found.regs.ebp + 0x44, 20)

i = 0
for byte in hashout.chop(8):
	state_found.add_constraints(byte == s_hash[i])
	i += 1

state_found.se.eval(argv1)
	
